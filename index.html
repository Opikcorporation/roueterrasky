function createWheel() {
    wheelDiv.innerHTML = '';
    textContainer.innerHTML = '';
    const numSegments = participants.length;
    const anglePerSegment = 360 / numSegments;
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("viewBox", "0 0 500 500");
    
    const wheelRadius = wheelDiv.offsetWidth / 2; // rayon rÃ©el de la roue
    const textRadius = wheelRadius * 0.65; // distance idÃ©ale du centre

    participants.forEach((name, i) => {
        const startAngle = i * anglePerSegment;
        const endAngle = startAngle + anglePerSegment;
        const path = document.createElementNS(svgNS, "path");
        const x1 = 250 + 250 * Math.cos(Math.PI * startAngle / 180), y1 = 250 + 250 * Math.sin(Math.PI * startAngle / 180);
        const x2 = 250 + 250 * Math.cos(Math.PI * endAngle / 180), y2 = 250 + 250 * Math.sin(Math.PI * endAngle / 180);
        path.setAttribute("d", `M250,250 L${x1},${y1} A250,250 0 0,1 ${x2},${y2} z`);
        path.setAttribute("fill", segmentColors[i % segmentColors.length]);
        svg.appendChild(path);
        
        // Angle centrÃ© pour le texte
        const textAngle = startAngle + anglePerSegment / 2;
        const textDiv = document.createElement('div');
        textDiv.className = 'participant-text';
        
        const textSpan = document.createElement('span');
        const truncatedName = name.length > 8 ? name.substring(0, 6) + '...' : name;
        textSpan.innerText = truncatedName;
        textDiv.appendChild(textSpan);
        
        // Calcul coordonnÃ©es
        const textX = textRadius * Math.cos(textAngle * Math.PI / 180);
        const textY = textRadius * Math.sin(textAngle * Math.PI / 180);
        
        // On garde le texte horizontal en annulant la rotation aprÃ¨s positionnement
        textDiv.style.left = `calc(50% + ${textX}px)`;
        textDiv.style.top = `calc(50% + ${textY}px)`;
        textDiv.style.transform = `translate(-50%, -50%) rotate(${textAngle}deg) rotate(${-textAngle}deg)`;
        
        textContainer.appendChild(textDiv);
    });
    
    wheelDiv.appendChild(svg);
}

// -------- SPIN : AJOUT OFFSET POUR ALIGNEMENT CURSEUR --------
spinButton.addEventListener('click', () => {
    if (isSpinning || currentWinnerIndex >= predefinedWinners.length) return;

    const winnerName = predefinedWinners[currentWinnerIndex];
    isSpinning = true; 
    spinButton.disabled = true;
    const winnerIndexOnWheel = participants.indexOf(winnerName);

    if (winnerIndexOnWheel === -1) {
        alert(`Erreur : Gagnant "${winnerName}" non trouvÃ© sur la roue.`);
        isSpinning = false; 
        spinButton.disabled = false; 
        return;
    }

    const anglePerSegment = 360 / participants.length;
    let winnerAngle = (winnerIndexOnWheel * anglePerSegment) + (anglePerSegment / 2);

    // ðŸ”¥ Correction : DÃ©calage pour que 0Â° corresponde au haut
    winnerAngle += 90; 

    const targetRotation = -winnerAngle;
    const currentRotation = gsap.getProperty(textContainer, "rotation") % 360;
    const finalRotation = (360 * totalSpins) + targetRotation - currentRotation;
    
    spinSound.play();
    gsap.to([wheelDiv, textContainer], {
        rotation: `+=${finalRotation}`, 
        duration: spinDuration, 
        ease: "power4.out",
        onComplete: () => {
            spinSound.stop();
            isSpinning = false; 
            announceWinner(winnerName);
        }
    });
});
